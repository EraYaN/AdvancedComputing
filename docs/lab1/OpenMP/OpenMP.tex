%!TEX program=xelatex
%!TEX spellcheck=en_US
\documentclass[final]{report}
\input{../../.library/preamble.tex}
\input{../../.library/style.tex}
\addbibresource{../../.library/bibliography.bib}
\begin{document}
\chapter{OpenMP}
%TODO OpenMP Test Number of threads. DP and SP.
\section{Task 1}
In order to find the most suitable number of threads a fixed data size of 2048 bytes with a sweep from 1 to 64 threads has been used.
\begin{figure}[H]
\centering
    \includegraphics[width=\linewidth]{resources/openmp-number-of-threads-sweep.pdf}
    \caption{The speedup of the OpenMP version with varying threads, uses a data\_size of 2048.}
    \label{fig:openmp-number-of-threads-sweep}
\end{figure}
Looking at \autoref{fig:openmp-number-of-threads-sweep}, the first thing that comes to mind is the sharp inclination in speedup till 8 threads after which the speedup basically stalls.
The initial increase in speedup is obvious, as the vector matrix multiplication is processed in parallel.
Only 1 thread gives a speedup of 1, whereas 2 threads give a speedup of 1.75.
It gets interesting near the 3th-4th, 5th-6th and the 7th-8th number of threads.
Here the 4th, 6th and 8th number of threads seem not to be contributing to the speedup, on the contrary they even cause a slight bump in speedup.
The bump is likely caused due to the extra overhead of talking to an extra thread.

%TODO OpenMP Test Data Size. DP and SP.
\begin{figure}[H]
\centering
    \includegraphics[width=\linewidth]{resources/openmp-data-size-sweep.pdf}
    \caption{The speedup of the OpenMP version with varying data\_size, uses 50 threads.}
    \label{fig:openmp-data-size-sweep}
\end{figure}

In \cref{lst:openmp-matrix-snippet} our matrix OpenMP code is shown, the inner loop is added to sum over all rows of the first matrix.
\includecode[cpp]{OpenMP Matrix x Matrix Snippet}{resources/OpenMPMatrixSnippet.cpp}{lst:openmp-matrix-snippet}

\end{document}